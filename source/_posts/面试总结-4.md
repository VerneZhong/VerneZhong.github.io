---
title: 面试总结-4
date: 2020-08-26 16:45:27
categories: 
- 面试总结
tags:
- 面试总结
---

## 												面试总结-某地产

### gRPC 如何做负载的



### gRPC 限流怎么做的

### Dubbo 如何做负载的



### Spring 循环依赖怎么解决的，为什么使用三级缓存？

### Spring Bean 生命周期

### Spring  动态代理和CGLIB代理区别

JDK反射基于Java反射实现

cglib是基于字节码提升

### Spring  的BeanPostProcessor和BeanFactoryPostProcessor区别

BeanPostProcessor接口：后置bean处理器，允许自定义修改新的bean实例，应用程序上下文可以在其bean定义中自动检测BeanPostProcessor类型的bean，并将它们应用于随后创建的任何bean。（例如：配置文件中注册了一个自定义BeanPostProcessor类型的bean，一个User类型的bean，应用程序上下文会在创建User实例之后对User应用BeanPostProcessor）。

BeanFactoryPostProcessor接口：后置工厂处理器，允许自定义修改应用程序上下文的bean定义，调整bean属性值。应用程序上下文可以在其bean定义中自动检测BeanFactoryPostProcessor，并在创建任何非BeanFactoryPostProcessor类型bean之前应用它们（例如：配置文件中注册了一个自定义BeanFactoryPostProcessor类型的bean，一个User类型的bean，应用程序上下文会在创建User实例之前对User应用BeanFactoryPostProcessor）。

### HashMap 如何解决hash碰撞，以及何时扩容的

### ArrayList与LinkedList区别

### LinkedHashMap如何实现有序的

### Queue的阻塞队列用过哪几种

### ArrayBlockingQueue和LinkedBlockingQueue区别，以及怎么实现的

### DelayQueue如何实现的

### AQS的实现原理

### CMS的原理

### 事务的隔离级别，以及分别解决了什么

### Mysql除了可重复读的隔离级别还有哪些？

|         事务隔离级别         | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
|    串行化（serializable）    |  否  |     否     |  否  |

### Mysql索引为什么使用B+tree

### Mysql的最左匹配原则是什么

### Mysql的锁有哪些

[参考官方文档](https://docs.oracle.com/cd/E17952_01/mysql-5.5-en/innodb-locking.html#innodb-shared-exclusive-locks)

共享锁和排他锁：

InnoDB实现标准的行级锁定，其中有两种类型的锁定：共享（S）锁定和排他（X）锁定。

- 共享（S）锁允许持有该锁的事务读取一行。


- 排他（X）锁允许持有该锁的事务更新或删除行。

意向锁：

InnoDB支持多种粒度锁定，允许行锁和表锁并存。 例如，诸如LOCK TABLES ... WRITE之类的语句对指定表采用排他锁（X锁）。 为了使在多个粒度级别上的锁定变得切实可行，InnoDB使用了意图锁定。 意向锁是表级锁，指示事务稍后对表中的行需要哪种类型的锁（共享锁或排他锁）。 有两种类型的意图锁：

- 意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。


- 意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。

### Redis如何实现持久化的，如果在快照持久化的过程中有写数据如何解决的

*Redis 提供了不同级别的持久化方式：*

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.
- 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
- 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.
- 最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始

*RDB 优点：*

- RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.
- RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.
- RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.
- 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些

*RDB 缺点：*

- 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.
- RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.

*AOF 优点*

- 使用AOF会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.
- AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.
- Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。
- AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

*AOF 缺点：*

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
- 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。



### 消息中间件用过哪些



### 消息中间件如何广播消息的

### 项目中如何做链路跟踪的

### dubbo的负载均衡策略和容错策略

#### 一、dubbo 负载均衡策略

- #### random loadbalance

　　默认情况下，dubbo 是 random load balance 随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。

- #### roundrobin loadbalance

　　这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。

- #### leastactive loadbalance

　　这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求。

- #### consistanthash loadbalance

　　一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。

#### 二、dubbo 集群容错策略

- #### failover cluster 模式

　　失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）

- #### failfast cluster模式

　　一次调用失败就立即失败，常见于写操作。（调用失败就立即失败）

- #### failsafe cluster 模式

　　出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。

- #### failback cluster 模式

　　失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。

- #### forking cluster 模式

　　并行调用多个 provider，只要一个成功就立即返回。

- #### broadcacst cluster

　　逐个调用所有的 provider。