---
title: 面试总结-4
date: 2020-08-26 16:45:27
categories: 
- 面试总结
tags:
- 面试总结
---

## 												面试总结-某地产

### gRPC 如何做负载的



### gRPC 限流怎么做的

### Dubbo 如何做负载的



### Spring 循环依赖怎么解决的，为什么使用三级缓存？

### Spring Bean 生命周期

### Spring动态代理和CGLIB代理区别

JDK反射基于Java反射实现

cglib是基于字节码提升

### Spring的BeanPostProcessor和BeanFactoryPostProcessor区别

BeanPostProcessor接口：后置bean处理器，允许自定义修改新的bean实例，应用程序上下文可以在其bean定义中自动检测BeanPostProcessor类型的bean，并将它们应用于随后创建的任何bean。（例如：配置文件中注册了一个自定义BeanPostProcessor类型的bean，一个User类型的bean，应用程序上下文会在创建User实例之后对User应用BeanPostProcessor）。

BeanFactoryPostProcessor接口：后置工厂处理器，允许自定义修改应用程序上下文的bean定义，调整bean属性值。应用程序上下文可以在其bean定义中自动检测BeanFactoryPostProcessor，并在创建任何非BeanFactoryPostProcessor类型bean之前应用它们（例如：配置文件中注册了一个自定义BeanFactoryPostProcessor类型的bean，一个User类型的bean，应用程序上下文会在创建User实例之前对User应用BeanFactoryPostProcessor）。

### HashMap 如何解决hash碰撞，以及何时扩容的

**Hash冲突**：由于用于计算的数据是无限的`H(key),key属于(-∞,+∞)`,而映射到区间是有限的，所以肯定会存在两个key:key1,key2，H(key1)=H(key2)，这就是hash冲突。一般的解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。

开放地址法：也称为`再散列法`，基本思想就是，如果`p=H(key)`出现冲突时，则以`p`为基础，再次hash，`p1=H(p)`,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址`pi`。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以`只能在删除的节点上做标记，而不能真正删除节点。`

缺点:容易产生堆积问题;不适合大规模的数据存储;插入时会发生多次冲突的情况;删除时要考虑与要删除元素互相冲突的另一个元素，比较复杂。

再哈希法(双重散列，多重散列)：提供多个不同的hash函数，当`R1=H1(key1)`发生冲突时，再计算`R2=H2(key1)`，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。

链地址法(拉链法)：将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。HashMap采用的就是链地址法来解决hash冲突。(链表长度大于等于8时转为红黑树)

建立公共溢出区：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

何时扩容：HashMap的容量是有限的。当经过多次元素插入的时候，使得HashMap达到一定的饱和度，Key映射位置的几率不断变大。这个时候，HashMap就需要扩容了，也就是Resize。**当 HashMap.size >= Capacity\*LoadFactor 时，HashMap可能会进行Resize。**

Hashmap的扩容需要满足两个条件：**当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。**

### ArrayList与LinkedList区别

ArrayList基于数组实现的

LinkeddList基于链表实现的

### LinkedHashMap如何实现有序的

### Queue的阻塞队列用过哪几种

Java提供了7个阻塞队列：

- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列
  - ArrayBlockingQueue按照先进先出（FIFO）的原则对元素进行排序
  - 默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照先后顺序访问队列
  - 非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格
  - 为了保证公平性，通常会降低吞吐量
- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列
  - LinkedBlockingQueue队列默认和最大长度为Integer.MAX_VALUE
  - 此队列也是按照先入先出（FIFO）的原则对元素进行排序
- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列
  - 默认情况下元素采取自然顺序升序排列
  - 也可以自定义实现compareTo()方法来指定元素排序规则，或者初始化时，指定构造参数Comparator来对元素进行排序
  - 需要注意的是不能保证同优先级元素的顺序
- DelayQueue：一个支持延时获取元素的无界阻塞队列
  - DelayQueue队列使用PriorityQueue来实现
  - 队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素
  - 只有在延迟期满时才能从队列中提取元素
- SynchronousQueue：一个不存储元素的阻塞队列
  - 是一个不存储元素的阻塞队列
  - 每个put操作必须等待一个take操作，否则不能继续添加元素
  - 它支持公平访问队列，默认采用非公平性策略访问队列
  - 该队列非常适合传递性场景
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
  - 是一个由链表结构组成的无界阻塞TransferQueue队列
  - 相比于其他阻塞队列，LinkedTransferQueue多个tryTransfer和transfer方法
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列
  - 是一个由链表结构组成的双向阻塞队列
  - 所谓双向队列指的是可以从队列的两端插入和移出元素
  - 双向队列因为多了一个操作队列的入口、在多线程同时入队时，也就减少了一半的竞争
  - 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀
  - 另外双向阻塞队列可以运用在“工作窃取”模式中

### AQS的实现原理

### CMS的原理

### 事务的隔离级别，以及分别解决了什么

### Mysql除了可重复读的隔离级别还有哪些？

|         事务隔离级别         | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
|    串行化（serializable）    |  否  |     否     |  否  |

### Mysql索引为什么使用B+tree

### Mysql的最左匹配原则是什么

### Mysql的锁有哪些

[参考官方文档](https://docs.oracle.com/cd/E17952_01/mysql-5.5-en/innodb-locking.html#innodb-shared-exclusive-locks)

共享锁和排他锁：

InnoDB实现标准的行级锁定，其中有两种类型的锁定：共享（S）锁定和排他（X）锁定。

- 共享（S）锁允许持有该锁的事务读取一行。


- 排他（X）锁允许持有该锁的事务更新或删除行。

意向锁：

InnoDB支持多种粒度锁定，允许行锁和表锁并存。 例如，诸如LOCK TABLES ... WRITE之类的语句对指定表采用排他锁（X锁）。 为了使在多个粒度级别上的锁定变得切实可行，InnoDB使用了意图锁定。 意向锁是表级锁，指示事务稍后对表中的行需要哪种类型的锁（共享锁或排他锁）。 有两种类型的意图锁：

- 意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。


- 意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。

### Redis如何实现持久化的，如果在快照持久化的过程中有写数据如何解决的

*Redis 提供了不同级别的持久化方式：*

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.
- 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
- 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.
- 最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始

*RDB 优点：*

- RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.
- RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.
- RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能.
- 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些

*RDB 缺点：*

- 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.
- RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.

*AOF 优点*

- 使用AOF会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.
- AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题.
- Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。
- AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

*AOF 缺点：*

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
- 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。



### 消息中间件用过哪些



### 消息中间件如何广播消息的

### 项目中如何做链路跟踪的

### dubbo的负载均衡策略和容错策略

#### 一、dubbo 负载均衡策略

- #### random loadbalance

　　默认情况下，dubbo 是 random load balance 随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。

- #### roundrobin loadbalance

　　这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。

- #### leastactive loadbalance

　　这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求。

- #### consistanthash loadbalance

　　一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。

#### 二、dubbo 集群容错策略

- #### failover cluster 模式

　　失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器）

- #### failfast cluster模式

　　一次调用失败就立即失败，常见于写操作。（调用失败就立即失败）

- #### failsafe cluster 模式

　　出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。

- #### failback cluster 模式

　　失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。

- #### forking cluster 模式

　　并行调用多个 provider，只要一个成功就立即返回。

- #### broadcacst cluster

　　逐个调用所有的 provider。