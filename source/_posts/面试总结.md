---
title: 面试总结
date: 2020-08-18 16:13:23
categories: 
- 面试总结
tags:
- 面试
- 某电商公司
---

## 													面试总结

### Mybatis 懒加载	

#### 什么是懒加载

延迟加载又叫懒加载，也叫按需加载，也就是说先加载主信息，需要的时候，再去加载从信息。代码中有查询语句，当执行到查询语句时，并不是马上去DB中查询，而是根据设置的延迟策略将查询向后推迟。

#### 作用

减轻DB服务器的压力，因为我们延迟加载只有在用到需要的数据才会执行查询操作。

#### 如何配置

- Mybatis-config.xml里配置：

```xml
<settings>
   <setting name ="aggressiveLazyLoading" value="false"/>
   <!--开启延迟加载-->
   <setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

- Mapper里配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xxx.mapper.AccountMapper">
	<!-- 定义封装 Account和User 的resultMap -->
    <resultMap id="userAccountMap" type="Account">
        <id property="id" column="id"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 配置封装 User 的内容
            select：查询用户的唯一标识
            column：用户根据id查询的时候，需要的参数值
        -->
        <association property="user" column="uid" javaType="User" 	select="com.xxx.mapper.UserMapper.findById"></association>
    </resultMap>

    <!-- 根据查询所有账户 -->
    <select id="findAll" resultMap="userAccountMap">
        SELECT * FROM account
    </select>
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xxx.mapper.UserMapper">
    <!-- 定义User的resultMap-->
    <resultMap id="userAccountMap" type="User">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="telephone" column="telephone"></result>
        <result property="birthday" column="birthday"></result>
        <result property="gender" column="gender"></result>
        <result property="address" column="address"></result>
        <collection property="accounts" ofType="account">
            <id property="id" column="aid"></id>
            <result property="uid" column="uid"></result>
            <result property="money" column="money"></result>
        </collection>
    </resultMap>

    <!-- 根据id查询用户 -->
    <select id="findById" parameterType="INT" resultType="User">
        select * from user where id = #{uid}
    </select>
</mapper>
```

就可以实现按需加载，达到我们的目的。

### 分布式锁如何实现

#### 基于数据库

在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

```mysql
DROP TABLE IF EXISTS `method_lock`;
CREATE TABLE `method_lock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
  `desc` varchar(255) NOT NULL COMMENT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```

执行某个方法后，插入一条记录

```mysql
INSERT INTO method_lock (method_name, desc) VALUES ('methodName', '测试的methodName');
```

因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

成功插入则获取锁，执行完成后删除对应的行数据释放锁：

```mysql
delete from method_lock where method_name ='methodName';
```

优点：易于理解实现

缺点：

（1）因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换。 

（2）不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程信息相同，若相同则直接获取锁； 

（3）没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在锁中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据； 

（4）不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

#### 基于Redis

选择Redis分布式锁的原因：

- redis有很高的性能； 

- redis对此支持的命令较好，实现起来比较方便

使用的命令：

- SETNX：`SETNX key val` 当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0
- expire：`expire key timeout` 设置超时时间，单位为s，超过这个时间就会自动释放锁，避免死锁
- delete：`delete key` 释放锁

实现思想：

1. 获取锁的时候，使用setnx加锁，并使用expire命令给锁加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 
2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 
3. 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行进行锁释放。

优点：

1. 吞吐量高
2. 有锁失效自动删除机制，保证不会阻塞所有流程

缺点:

1. 单点故障问题
2. 锁超时问题：如果A拿到锁之后设置了超时时长，但是业务还未执行完成且锁已经被释放，此时其他进程就会拿到锁从而执行相同的业务。如何解决？Redission定时延长超时时长避免过期。为什么不直接设置为永不超时？为了防范业务方没写解锁方法或者发生异常之后无法进行解锁的问题
3. 轮询获取锁状态方式太过低效

#### 基于Zookeeper

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。

基于ZooKeeper实现分布式锁的步骤如下：

1. 创建一个目录mylock； 
2. 线程A想获取锁就在mylock目录下创建临时顺序节点；
3. 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 
4. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己小的节点； 
5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如redis方式，强依赖zk

### DynamoDB 优势



### Spring 如何解决循环依赖

Spring 只能解决单例Bean的循环依赖，不能处理Bean Scope 为其他类型的Bean，
并且不能解决构造器注入

### Mysql 索引的数据结构，以及复杂度

B+Tree O(n)

### SpringBoot 运行原理

### Dubbo 服务挂了，如何实现重试？

### K8s的作用，如何编排

### 线程池的原理，参数配置

### G1和CMS的区别

G1的停顿时间如何设置
-XX:MaxGCPauseMillis=50

### Mysql数据库的默认隔离级别

### rpc框架的原理，序列化在哪一层

### gRPC 如何实现服务发现以及使用的什么负载均衡策略

服务发现与负载均衡
当server端是集群部署时，client调用server就需要用到服务发现与负载均衡。通常有两总方式：

一种方式是在client与server之间加代理，由代理来做负载均衡
一种方式是将服务注册到一个数据中心，client通过数据中心查询到所有服务的节点信息，然后自己选择负载均衡的策略