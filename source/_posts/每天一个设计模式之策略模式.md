---
title: 每天一个设计模式之策略模式
date: 2020-08-09 15:27:32
categories: 
- 后端技术
tags:
- 设计模式
- 策略模式
---

## 每天一个设计模式之策略模式

### 什么是策略模式 ？

- 定义一系列算法，封装每个算法，并使它们可互换。策略模式使算法独立于使用该算法的客户端而变化。

<!-- more -->

### 为什么使用策略模式 ？

####   先简单的模拟鸭子的应用做起

   系统的内部设计使用标准的OOP技术，设计了一个鸭子的超类（Superclass），并让各种鸭子继承此超类。

```java
/**
 * 鸭子超类
 */
public abstract class AbstractDuck {

    /**
     * 嘎嘎叫
     */
    protected void quack() {
        System.out.println("嘎嘎叫...");
    }

    /**
     * 游泳
     */
    protected void swim() {
        System.out.println("游泳...");
    }

    /**
     * 由于每种鸭子外观不同，提供抽象方法
     */
    protected abstract void display();
    
    // other method...
}
```

```java
/**
 * 绿头鸭
 */
public class MallardDuck extends AbstractDuck {
    @Override
    protected void display() {
        System.out.println("头是绿色的.");
    }
}
```

```java
/**
 * 红头鸭
 */
public class RedheadDuck extends AbstractDuck {
    @Override
    protected void display() {
        System.out.println("头是红色的.");
    }
}
```

后来新增了需求，让鸭子飞起来。于是在Duck超类加上fly()方法，然后所有的鸭子继承fly()。

```java
/**
 * 鸭子超类
 */
public abstract class AbstractDuck {
    // other method ...
    
     protected void fly() {
        System.out.println("鸭子飞起来...");
    }
}
```

但是，可怕的问题发生了....

由于并发所有的Duck类都会飞，在超类加上新的行为，会使得某些并不合适该行为的子类也具有该行为。当涉及维护时，为了复用目的而使用继承并不完美。

#### 利用接口改造

可以把fly()从超类中提取出来，放进“Flyable接口”中，这么一来，只有会飞的鸭子才实行此接口。同样方式，也可以用设计一个“Quackable接口”，因为不是所有的鸭子都会叫。

```java
public interface Flyable {
    void fly();
}
```

```java
public interface Quackable{
 	void quack();   
}
```

```java
/**
 * 鸭子超类
 */
public abstract class AbstractDuck {
    /**
     * 游泳
     */
    protected void swim() {
        System.out.println("游泳...");
    }

    /**
     * 由于每种鸭子外观不同，提供抽象方法
     */
    protected abstract void display();
    
    // other method ...
}
```

