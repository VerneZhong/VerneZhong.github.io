---
title: Jvm记录
date: 2020-08-06 16:53:36
categories: 
- Java相关
tags:
- Jvm
- GC
---
## JVM运行时数据区域

### 程序计数器（Program Counter Register）

- 内存大小：是一块比较小的内存空间
- 作用：当前线程所执行的字节码的行号指示器，在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

<!-- more -->

- 功能

  - 程序控制流的指示器
  - 分支
  - 循环
  - 跳转
  - 异常处理
  - 线程恢复

- 内存属性：各个线程之间计数器互不影响，“线程私有”

### Java虚拟机栈（Java Virtual Machine Stacks）

- 描述

  - Java方法执行的内存模型，每个方法执行时都会创建栈帧（Stack Frame）

- 栈帧

  - 存储局部变量表

    - 基本数据类型（boolean、byte、char、short、int、float、double、long）
    - 对象引用（reference类型）
    - returnAddress类型（字节码指令地址）

  - 操作数栈
  - 动态连接
  - 方法出口

- 内存属性：线程私有，生命周期与线程相同
- 异常

  - StackOverflowError

    - 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常

  - OutOfMemoryError

    - 如果虚拟机栈容量可扩展，当栈扩展时无法申请到足够内存，抛出OutOfMemoryError异常（Classic虚拟机栈可以动态扩展）
    - 在HotSpot虚拟机的栈容量是不可动态扩展，所以不会因为动态扩展而OOM，只要线程申请栈空间成功了就不会有OOM，但是申请失败仍然会有OOM异常

### 本地方法栈（Native Method Stack）

- 功能与虚拟机栈非常相似，区别：

  - Java虚拟机栈为虚拟机执行Java方法（字节码）服务
  - 本地方法栈为虚拟机使用Native方法服务

- 异常

  - StackOverflowError

    - 当栈深度溢出则抛出

  - OutOfMemoryError

    - 当扩展失败时抛出

### Java堆（Java Heap）

- 描述

  - 内存大小：Jvm所管理的内存中最大的一块
  - 被所有线程所共享的区域
  - 作用：存放对象实例，几乎所有的对象实例都在堆里分配内存，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术会发生微妙变化
  - 堆是垃圾收集器管理的主要区域，因此被称为GC堆
  - 堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可
  - Java堆既可以被实现成固定大小，也可以是可扩展的（通过参数-Xmx和-Xms设定）

- 分类

  - 内存回收角度

    - 现在收集器基本采用分代收集算法

      - 以G1收集器为分界，都基于经典分代来设计（不适合当下情况）

        - 新生代

          - Eden space
          - To Survivor space
          - From Survivor space

        - 老年代
        - 永久代（PermGen）

          - 在Jdk8已经删除，替换成元空间（Metaspaces）

      - HotSpot目前采用不分代设计的新垃圾收集器

  - 内存分配角度

    - 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB），以提升分配对象的效率

- 异常

  - OutOfMemoryError

    - 堆没有内存完成实例分配，并且无法扩展时，抛出OOM异常

### 方法区（Method Area）

- 描述

  - 和Java堆一样，被所有线程所共享，又称Non-Heap（非堆）
  - 在JDK8以前，又把方法区称为“永久代”，其实两者不等价，只是使用永久代来实现方法区而已，这样HotSpot虚拟机就可以像管理堆一样管理这块内存
  - 对于其他虚拟机是不存在永久代概念，在JDK7以前，是很容易导致OOM PermGen space内存溢出的问题
  - 从JDK6开始HotSpot就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区
  - 从JDK7开始，HotSpot把原来放在永久代的字符串常量池、静态变量等从方法区移出到堆里
  - 到了JDK8已经完全废弃了，HotSpot把永久代剩余的类型信息全部移到元空间中

- 作用：用来存储

  - 类信息
  - 常量
  - 静态变量
  - 即时编译器编译后的代码缓存

- 内存回收：

  - 对常量池对回收
  - 对类型的卸载

- 异常

  - OutOfMemoryError

    - 当方法区无法满足内存分配需求时，抛出OOM异常

- 运行时常量池（Runtime Constant Pool）

  - 描述

    - 方法区的一部分
    - Class文件中除了有类的版本信息、字段、方法、接口等描述信息外，还有一项是常量池表，用于存放编译期生成等各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量池中

  - 作用

    - 存储编译期生成的各种字面量
    - 符号引用

  - 异常

    - OutOfMemoryError

      - 当常量池无法申请内存时，抛出OOM异常

### 直接内存（堆外内存）

- 并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域，是直接受操作系统管理
- 在NIO中的DirectByteBuffer对象就是进行堆外内存管理和使用的，它会在对象创建的时候就分配堆外内存。DirectByteBuffer类是在Java Heap外分配内存，对堆外内存的申请主要是通过成员变量Unsafe来操作
- 好处：能够在一定程度上减少垃圾回收对应用程序造成的影响
- 若忽略直接内存，会使各个内存区域总和大于物理内存限制，从而动态扩展时出现OOM异常

## HotSpot虚拟机

### 对象创建

- 1. 检查指令参数是否在常量池定位到类的符号引用

- 2. 检查符号引用的类是否已加载、解析、初始化

- 3. 为新生对象分配内存

  - 堆内存规整，则用指针碰撞方式分配
  - 堆内存不规整，则用空闲列表方式分配
  - 堆内存规整与否，取决于采用的垃圾收集器是否带有空间压缩整理的能力
  - 当使用Serial、ParNew等带有压缩整理过程的收集器，系统采用等是指针碰撞方式
  - 使用CMS这种基于清除（Sweep）算法的收集器时，理论上只能采用较为复杂的空闲列表来实现分配
  - 内存分配安全方式

    - 对分配对内存空间动作进行同步处理

      - CAS+失败重试来保证更新操作对原子性

    - 内存分配对动作按照线程划分在不同对空间之中进行

      - 即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAP）

- 4. 将分配到的内存空间都初始化为0（不包括对象头）

- 5. 为对象进行必要设置

- 6. 执行init为对象初始化

### 对象的内存布局

- 对象头（Header）

  - 存储对象自身的运行时数据，也被称为“Mark Word”

    - 哈希吗（HashCode）
    - GC分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳

  - 类型指针

    - 对象指向它的类元数据的指针
    - 虚拟机通过指针来确定对象是哪个实例

  - 对象若是数组，必须有一块记录数组长度的数据，普通对象JVM可以通过元数据信息获取对象大小，而数组的元数据无法确定大小

- 实例数据（Instance Data）

  - 对象真正存储的有效信息，也是程序定义的各种类型的字段内容
  - HotSpot虚拟机分配策略是相同宽度的字段总是被分配在一起

- 对齐填充（Padding）

  - 不是必要的，起着占位符的作用
  - HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍
  - 当对象实例没有对齐时，就需要通过填充来补全

### 对象的访问定位

- Java程序通过栈上的reference数据来操作堆上的具体对象，至于通过什么方式定位引用对象，通过以下两种主流方式
- 句柄

  - 堆分配一块内存作为句柄池，reference中存储对象的句柄地址
  - 优势：reference存储句柄地址，对象移动时只会改变句柄中实例数据指针，而reference本身不用修改

- 直接指针

  - reference存储的直接就是对象地址
  - 优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java非常频繁，因为节省的开销是非常可观的
  - HotSpot 就是使用直接指针方式定位对象

## 垃圾收集器（Garbage Collection，GC）

### 垃圾收集算法

- 对象存活判断算法

  - 引用计数算法

    - 描述：是在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不能再被使用
    - 主流Java虚拟机并没有选用引用计数算法来管理内存
    - 原因是该算法很难解决对象之间互相循环引用的问题

  - 可达性分析算法

    - 描述：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链（Reference Chain）”，如果某个对象到GC Roots间没有任何引用链相连或从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的
    - GC Roots对象

      - 虚拟机栈中引用的对象，比如各线程调用方法堆栈中使用的参数、局部变量、临时变量等
      - 方法区中类静态属性引用的对象，比如字符串常量池里的引用
      - 方法区中类静态属性引用的对象，比如Java类的引用类型静态变量
      - 本地方法栈中JNI引用的对象
      - Java虚拟机内部的引用，比如：基本数据类型对应的Class对象，以及一些异常对象（NPE、OOM）等，还有系统类加载器
      - 所有被同步锁（synchronized关键字）持有的对象
      - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

    - 引用

      - 无论通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用“有关
      - 分类

        - 强引用（Strongly Reference）

          - 不会被垃圾收集器回收掉的引用

        - 软引用（Soft Reference）

          - 当JVM将要发生内存溢出前，会回收这部分引用，若内存还是不够，则OOM

        - 弱引用（Weak Reference）

          - 被弱引用关联的对象只能生存到下一次垃圾收集发生为止

        - 虚引用（Phantom Reference）

          - 最弱的引用关系，无法造成任何影响，也无法通过虚引用获取一个对象实例
          - 虚引用关联的唯一目的只是为了能在这个对象被垃圾收集器回收时候收到一个通知

- 引用计数式垃圾收集

  - 直接垃圾收集

    - 主流Java虚拟机中均为涉及此算法
    - Objective-C采用此方式作为内存管理

- 追踪式垃圾收集（间接垃圾收集）

  - 分代收集算法

    - 弱分代假说

      - 大多数对象朝生夕死

    - 强分代假说

      - 熬过多次垃圾收集过程的对象越难以消亡

    - 根据以上假说多款收集器一致的设计原则：

      - 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储
      - 根据分代设计理论，一般至少会把Java堆划分为新生代和老年代，在新生代中，每次垃圾收集会有大量的对象死亡，而每次存活的少量对象晋升到老年代存放

    - 跨代引用假说

      - 跨代引用相对于同代引用来说仅占少数
      - 存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的
      - 依据该假说，就不用为了少量的跨代引用扫描整个老年代，也不必浪费空间专门记录每个对象是否存在或存在哪些跨代引用，只需要在新生代建立一个全局的数据结构（记忆集），这个结构把老年代划分若干个小块，标识出老年代的哪一块内存会存在跨代引用
      - 在Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，这样就不用扫描整个老年代了

    - 分类

      - 部分收集（Partial GC）

        - 目标不是完整收集整个Java堆的垃圾收集
        - 新生代收集（Minor GC/Young GC）

          - 目标只是新生代的垃圾收集

        - 老年代收集（Major GC/Old GC）

          - 目标只是老年代的垃圾收集
          - 目前只有CMS收集器会有单独收集老年代的行为

        - 混合收集（Mixed GC）

          - 目标是收集整个新生代以及部分老年代的垃圾收集
          - 目前只有G1收集器有这种行为

      - 整堆收集（Full GC）

        - 目标收集整个Java堆和方法区的垃圾收集

  - 标记-清除算法（Mark-Sweep）

    - 分为“标记”和“清除”两个阶段

      - 首先标记所有要回收的对象，在标记完成后，统一回收掉所有被标记的对象
      - 也可以反过来，标记存活的对象，统一回收所有未被标记的对象
      - 标记的过程就是对象是否属于垃圾的判断过程

    - 缺点

      - 执行效率不稳定

        - 如果堆中有大量的对象，其中大部分是要被回收堆，这时就需要大量标记和清除的动作，导致标记和清除过程的执行效率都随着对象的数量增长而降低

      - 内存空间碎片化问题

        - 标记/清除后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程需要分配较大的对象时无法找到足够的连续内存而提前触发一次GC动作

    - 在HotSpot虚拟机中

      - 关注低延迟的CMS收集器是基于标记-清除算法的，当内存空间碎片过多时CMS收集器就会采用标记-整理算法

  - 标记-复制算法

    - 简称复制算法，解决标记-清除算法面临大量对象执行效率低的问题

      - 就是将内存按容量划分为大小相等的两块，每次只是使用其中一块
      - 当这一块内存快使用完，就将存活的对象复制到另一块内存上面，然后把使用的这一块内存空间一次清理掉

    - 好处

      - 不用考虑空间碎片化问题，只需移动堆顶指针，按顺序分配即可，这样实现简单高效

    - 缺点

      - 如果内存中多数对象都是存活的，就会存在大量内存复制的开销
      - 将内存缩小为原来的一半，浪费了大量的空间

    - 根据以上特点提出更优化的半区复制分代策略（Appel式回收）

      - Appel式回收的做法

        - 将新生代分为

          - 一块较大的Eden空间
          - 两块较小的Survivor空间

        - 每次分配内存只使用Eden空间和其中一块Survivor空间，然后直接清理掉Eden空间和用过的那块Survivor空间
        - 发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用的Survivor空间
        - HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是新生代可用内存空间为整个新生代容量的90%（Eden80%+Survivor10%）
        - 但无法保证每次回收都有不多于10%对象存活，所以Appel式回收设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就要依赖其他内存区域（实际大多是老年代）进行分配担保（Handle Promotion）

      - HotSpot的Serial/ParNew等新生代收集器均采用这种策略来设计新生代内存布局

  - 标记-整理算法（Mark-Compact）

    - 标记过程仍与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都像内存空间一端移动，然后直接清理掉边界以外的内存
    - 标记-清除和标记-整理本质区别：前者是非移动式的回收算法，后者是移动式的
    - 缺点

      - 移动存活对象，在老年代中每次回收都有大量对象存活的区域，移动存活对象并更新所有引用这些对象的地方将会是极为繁重的操作
      - 对象移动操作必须全程暂停用户程序才能进行
      - 若不移动和整理存活对象，将会导致空间碎片化问题

        - 就只能依赖复杂的内存分配器和内存访问器来解决

    - 在HotSpot虚拟机中

      - 关注吞吐量的收集器Parallel Scavenge基于标记-整理算法

### HotSpot算法实现

- 根结点枚举
- 安全点
- 安全区域
- 记忆集与卡集
- 写屏障
- 并发的可达性分析

### 经典垃圾收集器

- Serial收集器

  - 在JDK1.3以前是HotSpot虚拟机新生代收集器的唯一选择
  - 客户端模式下默认新生代收集器
  - 单线程工作的收集器
  - 优势

    - 和其他单线程收集器相比，简单而高效
    - 对于内存资源受限的环境，是所有收集器里额外内存消耗最小的
    - 对于单核处理器或处理器核心较少的环境来说，Serial收集器由于没有线程交互的开销，可以获得最高的单线程收集效率

- ParNew收集器

  - 是Serial收集器的多线程并行版本
  - ParNew收集器是激活CMS收集器后的默认新生代收集器
  - 从JDK9 G1收集器的出现，CMS+ParNew收集器的组合就不再是官方推荐的服务器模式下的默认收集器
  - ParNew收集器默认开启的收集线程数与处理器核心数量相同，也可以使用参数来限制垃圾收集器的线程数

- Parallel Scavenge收集器

  - 也是新生代收集器
  - 基于标记-复制算法实现的收集器
  - 也是并行收集的多线程收集器
  - 特点

    - 与其他收集器关注点不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间
    - Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量
    - 所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值
    - 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 运行垃圾收集器时间）
    - 所以Parallel Scavenge收集器又被称作“吞吐量优先收集器”

  - Parallel Scavenge收集器提供了两个参数用来精确控制吞吐量

    - 控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数
    - 直接设置吞吐量大小的-XX:GCTimeRatio参数

- Serial Old收集器

  - Serial Old收集器是Serial收集器的老年代版本
  - 也是一个单线程收集器
  - 使用标记-整理算法实现的收集器
  - 主要也是提供客户端模式下HotSpot虚拟机使用
  - 若是用于服务端模式下，则可能有两种用途

    - 在JDK5及以前的版本中与Parallel Scavenge收集器搭配使用
    - 是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用

- Parallel Old收集器

  - Parallel Old收集器是Parallel Scavenge收集器的老年代版本
  - 支持多线程并发收集，基于标记-整理算法实现
  - 从JDK6开始提供，为了解决Parallel Scavenge收集器的尴尬状态，原因在于Parallel Scavenge收集器，老年代除了Serial Old收集器以外别无选择，无法与其他表现良好的老年代收集器配合工作，如CMS收集器
  - 吞吐量优先收集器的组合，在注重吞吐量或者处理器资源较为稀缺的场合，可以考虑Parallel Scavenge加Parallel Old收集器这个组合

- CMS（Concurrent Mark Sweep）收集器

  - 以获取最短回收停顿时间为目标的收集器
  - 从名字来看CMS收集器是基于标记-清除算法实现的
  - 在JDK9以后不官方不推荐使用CMS收集器
  - 工作过程

    - 初始标记（CMS initial mark）

      - 标记一下GC Roots能直接关联到到对象，速度很快，需要停顿用户线程

    - 并发标记（CMS concurrent mark）

      - 从GC Roots直接关联对象开始遍历整个对象图的过程，该过程耗时长但不需要停顿用户线程

    - 重新标记（CMS remark）

      - 修正并发标记期间，因用户线程继续运作而导致标记产生变动但那一部分对象的标记记录，该阶段停顿的时间比初始标记要长一些，但也远比并发标记的时间要短

    - 并发清除（CMS concurrent sweep）

      - 清理删掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以该阶段也是可以和用户线程同时并发

  - 优点

    - 并发收集
    - 低停顿

  - 缺点

    - 对处理器资源非常敏感，在并发阶段，会导致应用程序变慢，降低了总吞吐量
    - CMS收集器默认启动的回收线程数是（处理器核心数量+3）/4

      - 如果处理器核心数在4个以上，并发回收时垃圾收集器只占用不超过25%的处理器运算资源，并且会随着处理器核心数增加而下降
      - 当处理器核心数不足4个时，CMS收集器对用户程序的影响就可能变得很大

    - 由于CMS收集器无法处理“浮动垃圾”，有可能出现“Concurrent Mode Failure”失败进而导致一次完全“Stop The World”的Full GC的产生

      - 浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集处理掉它们，只好留到下一次清理，这一部分垃圾就是浮动垃圾

    - 由于CMS是一款基于“标记-清除”算法实现的收集器，就会造成大量空间碎片产生，如果空间碎片过多时，当需要足够大大连续空间来分配大对象大时候，会不得不提前触发Full GC的情况

      - 解决方案

        - CMS收集器提供一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启，JDK9开始弃用），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的
        - 空间碎片问题虽然解决了，但停顿时间又会变长，因此虚拟机提供了参数-XX:CMSFullGCsBeforeCompaction（JDK9开始弃用），用于要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）

- Garbage First（G1）收集器

  - 什么是G1收集器

    - Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式
    - 从JDK7确立项目目标，G1收集器就被视为JDK7中HotSpot虚拟机的一项重要进化特征，直到JDK8 Update 40之后，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”
    - 面向服务端应用的垃圾收集器，HotSpot期望它代替CMS收集器，在JDK9中G1就代替Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则标记为不推荐使用的收集器，在未来CMS可能会被废弃

  - G1收集器设计模式

    - G1收集器以前的其他收集器，垃圾收集的目标范围要么是整个新生代（Minor GC），要么是老年代（Major GC），要么是整个Java堆（Full GC）；而G1跳出了这个樊笼，它可以面对堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收，衡量标准不在是属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的混合收集（Mixed GC）模式
    - G1开创基于Region的堆内存布局是它能够实现这个目标的关键
    - 虽然G1也遵循分代收集理论设计的，但在堆内存但布局与其他收集器有很大差异

      - G1不再坚持固定大小以及固定数量但分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Edge空间、Survivor空间或者老年代空间
      - G1收集器能根据不同的Region采用不同的策略去处理
      - Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象
      - 每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB-32MB，且为2的n次幂
      - 对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

    - 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合

      - G1收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集
      - 处理思路是让G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（-XX:MaxGCPauseMillis指定，默认是200ms），优先处理回收价值受益最大的那些Region，这也就是“Garbage First”名字的由来
      - 这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率

  - G1收集器运作过程（不计算用户线程运行过程中的动作）

    - 初始标记（Initial Marking）

      - 标记GC Roots能直接关联到到对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象
      - 该阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实行并没有额外的停顿

    - 并发标记（Concurrent Marking）

      - 从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时比较长，但可与用户线程并发执行
      - 当扫描图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象

    - 最终标记（Final Marking）

      - 对用户线程做另一个短暂对暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录

    - 筛选回收（Live Data Counting and Evacuation）

      - 负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间
      - 这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的

    - 总结

      - G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望

  - G1收集器特点

    - 可由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可让G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡

      - 默认停顿时间200ms，必须保证“期望值”符合实际
      - 若是停顿时间设置很低，则可能出现由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积，最终引发Full GC而降低性能
      - 所以期望停顿时间设置为100-200ms或200-300ms是比较合理的

    - 从G1开始，先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不是追求一次把整个Java堆全部清理干净

      - 这样应用在分配，同时收集器在收集，只要收集的速度能跟上对象分配的速度，那这一切能运作得很完美

  - G1收集器和CMS收集器比较

    - G1收集器相比CMS的优点

      - G1从整体来看是基于“标记-整理”算法实现的收集器，从局部上看（两个Region之间）又是基于“标记-复制”算法实现，无论如何，这两种算法在运行期间都不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存

        - 有利于应用程序长时间运行
        - 分配大对象时不容易造成无法找到连续内存空间而提前触发一次收集

      - 可以自定义指定最大停顿时间
      - 分Region的内存布局
      - 按收益动态确定回收集

    - G1收集器相比CMS的缺点

      - 在运行过程中，G1垃圾收集器内存占用（Footprint）要比CMS要高

        - G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更复杂，堆中每个Region，无论扮演新生代还是老年代角色，都必须有一份卡表，导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间
        - CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的

      - 程序运行时的额外执行负载（Overload）要比CMS高

        - 由于G1和CMS收集器各自实现特点导致用户程序运行时的负载会有不同，譬如它们都使用写屏障，CMS用写后屏障来更新维护卡表
        - G1除了使用写后屏障来进行同样的卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况

          - 相比增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担
          - 由于G1对写屏障的复杂操作要比CMS消耗更多对运算资源，所以CMS的写屏障实现时直接的同步操作， 而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理

    - 以上优缺点仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析，通常说哪款收集器要更好、要好上多少，往往是针对具体场景才能做的定量比较

      - 目前在小内存应用上CMS的表现大概率仍然会优于G1收集器
      - 而在大内存应用上G1则大多能发挥其优势
      - 这个优劣势的Java堆容量平衡点通常在6GB-8GB之间
      - 随着HotSpot对G1对不断优化，也会让对比结果继续向G1倾斜

### 低延迟垃圾收集器

- 垃圾收集器三项重要指标

  - 内存占用（Footprint）
  - 吞吐量（Throughput）
  - 延迟（Latency）

- 实验状态的低延迟垃圾收集器

  - Shenandoah收集器（存在于OpenJDK，而不存在于OracleJDK）
  - ZGC收集器

### 不垃圾回收的垃圾收集器

- Epsilon收集器

  - JDK11推出的不能够进行垃圾收集的垃圾收集器
  - 适用于运行数分钟或者数秒，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出

